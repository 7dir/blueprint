
@import "../../common/variables";
@import "./common";

/*
Numeric steppers

Numeric steppers provide controls for easily incrementing or decrementing a numeric value.

##### Keyboard interactions

- `↑` - increment the value by `stepSize` (default: `1`)
- `↓` - decrement the value by `stepSize` (default: `1`)
- `Shift + ↑` - increment the value by `majorStepSize` (default: `10`)
- `Shift + ↓` - decrement the value by `majorStepSize` (default: `10`)
- `Alt/Option + ↑` - increment the value by `minorStepSize` (default: `0.1`)
- `Alt/Option + ↓` - decrement the value by `minorStepSize` (default: `0.1`)
- `Enter` - triggers the `onDone` callback if one was provided; otherwise, sets invalid input to `0`

##### Mouse interactions

- `Click '+'` - increment the value by `stepSize` (default: `1`)
- `Click '-'` - decrement the value by `stepSize` (default: `1`)
- `Shift + Click '+'` - increment the value by `majorStepSize` (default: `10`)
- `Shift + Click '-'` - decrement the value by `majorStepSize` (default: `10`)
- `Alt/Option + Click '+'` - increment the value by `minorStepSize` (default: `0.1`)
- `Alt/Option + Click '-'` - decrement the value by `minorStepSize` (default: `0.1`)

##### Example

The following example is a configurable `NumericStepper` that responds to the keyboard and mouse interactions listed above.

@react-example NumericStepperExample

Weight: 10

Styleguide components.forms.numeric-stepper
*/

/*
JavaScript API

The `NumericStepper` component is available in the __@blueprintjs/core__ package.
Make sure to review the [general usage docs for JS components](#components.usage).

A numeric stepper can function as either an uncontrolled component or a semi-controlled component. It cannot
function as a purely controlled component, because it needs to adjust its own copy of the `value` internally
in response to keyboard and mouse interactions.

##### Uncontrolled mode

To use the numeric stepper in uncontrolled mode, simply pass an `onUpdate` callback into the component
to extract the value as the component changes it in response to keyboard and/or mouse interactions. The
component will invoke the callback after every value change, giving you the new value as a `string`.

```
import { NumericStepper } from BlueprintComponents;

export class NumericStepperExample extends React.Component<{}, {}> {
    public render() {
        return (
            <NumericStepper onUpdate={this.handleUpdate} />
        );
    }

    private handleUpdate = (value: string) => {
        console.log(value);
    }
}
```

##### Semi-controlled mode

Althrough the numeric stepper will always need to maintain state to preoprly adjust its value based on user
interactions, you can overwrite the current value by passing in a new `value` as a prop. Together with the
`onUpdate` and `onDone` callbacks, this makes it possible to extend the component's basic functionality in
a semi-controlled fashion. For instance, we could add support for evaluating mathematical expressions as
follows by taking in the expression via an `onDone` callback, evaluating it with some third-party library,
then passing the result back into the numeric stepper:

<div class="pt-callout pt-intent-primary pt-icon-info-sign">
  By default, non-numeric values will be reset to `null` when the stepper loses focus or when the user
  presses `Enter`. However, if you provide an `onDone` callback, the stepper will pass the current value
  through to that callback unaffected, side-stepping the default validation behavior. (Otherwise,
  mathematical expressions, which may include non-numeric characters, would be reset to `null` before those
  expressions could be evaluated.)
</div>

```
import { NumericStepper } from BlueprintComponents;

interface IState {
    value?: number | string;
}

export class NumericStepperExample extends React.Component<{}, IState> {

    public constructor() {
        super();
        this.state = { value: null };
    }

    public render() {
        return (
            <NumericStepper
                onDone={this.handleDone}
                value={this.state.value}
            />
        );
    }

    private handleDone = (value: string) {
        if (SomeLibrary.isNumber(value)) {
            return;
        }
        const result = SomeLibrary.evaluateMathExpression(value);
        this.setState({ value: result });
    }
}
```

@interface INumericStepperProps

Weight: -10

Styleguide components.forms.numeric-stepper.js
*/

$pt-numeric-stepper-z-index-below: 1;
$pt-numeric-stepper-z-index-above: 2;

.pt-numeric-stepper {
  .pt-button-group.pt-vertical > .pt-button {
    @include pt-button-height($pt-button-height);

    min-height: $pt-button-height / 2;
    line-height: $pt-button-height / 2 - 1px;

    &:first-child {
      border-radius: 0 $pt-border-radius 0 0;
      height: ($pt-button-height / 2) + 1;
    }

    &:last-child {
      border-radius: 0 0 $pt-border-radius 0;
      height: $pt-button-height / 2;
    }

    &[class*="pt-icon-"]::before {
      line-height: $pt-button-height / 2;
    }
  }

  // fix button border radii when the buttons are on the left
  .pt-button-group:first-child.pt-vertical > .pt-button {
    &:first-child {
      border-radius: $pt-border-radius 0 0 0;
    }

    &:last-child {
      border-radius: 0 0 0 $pt-border-radius;
    }
  }

  // lift the focused group to the top so that its focus outline
  // renders above everything else (you'd think this would happen
  // for free by using the pt-control-group, but the fact that we're
  // nesting groups within groups breaks that assumption).

  &.pt-numeric-stepper-button-group-focused {
    .pt-button-group {
      z-index: $pt-numeric-stepper-z-index-above;

      // within the button group's stacking context, lift the focused
      // button so that its focus outline appears on top when hovering
      // over sibling buttons.
      .pt-button:focus {
        z-index: $pt-numeric-stepper-z-index-above;
      }

      .pt-button:not(:focus) {
        z-index: $pt-numeric-stepper-z-index-below;
      }
    }

    .pt-input-group {
      z-index: $pt-numeric-stepper-z-index-below;
    }
  }

  &.pt-numeric-stepper-input-group-focused {
    .pt-input-group {
      z-index: $pt-numeric-stepper-z-index-above;
    }

    .pt-button-group {
      z-index: $pt-numeric-stepper-z-index-below;
    }
  }
}
