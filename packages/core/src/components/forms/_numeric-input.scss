
@import "../../common/variables";
@import "./common";

/*
Numeric inputs

Numeric inputs provide controls for inputting, incrementing, and decrementing a numeric value.

##### Keyboard interactions

- `↑/↓` - change the value by one step (default: `1`)
- `Shift + ↑/↓` - change the value by one major step (default: `10`)
- `Alt + ↑/↓` - change the value by one minor step (default: `0.1`)
- `Enter` - triggers the `onConfirm` callback if provided; otherwise, sets invalid input to `null`

##### Mouse interactions

- `Click ↑/↓` - change the value by one step (default: `1`)
- `Shift + Click ↑/↓` - change the value by one major step (default: `10`)
- `Alt + Click ↑/↓` - change the value by one minor step (default: `0.1`)

##### Example

The following example is a configurable `NumericInput` that responds to the keyboard and mouse interactions listed above.

@react-example NumericInputExample

Weight: 10

Styleguide components.forms.numeric-input
*/

/*
JavaScript API

The `NumericInput` component is available in the __@blueprintjs/core__ package.
Make sure to review the [general usage docs for JS components](#components.usage).

A numeric input can function as either an uncontrolled component or a semi-controlled component. It cannot
function as a purely controlled component, because it needs to adjust its own copy of the `value` internally
in response to keyboard and mouse interactions.

##### Uncontrolled mode

To use the numeric input in uncontrolled mode, simply pass an `onUpdate` callback into the component
to extract the value as the component changes it in response to keyboard and/or mouse interactions. The
component will invoke the callback after every value change, giving you the new value as a `string`.

```
import { NumericInput } from BlueprintComponents;

export class NumericInputExample extends React.Component<{}, {}> {
    public render() {
        return (
            <NumericInput onUpdate={this.handleUpdate} />
        );
    }

    private handleUpdate = (value: string) => {
        console.log(value);
    }
}
```

##### Semi-controlled mode

Althrough the numeric input will always need to maintain state to preoprly adjust its value based on user
interactions, you can overwrite the current value by passing in a new `value` as a prop. Together with the
`onUpdate` and `onConfirm` callbacks, this makes it possible to extend the component's basic functionality in
a semi-controlled fashion. For instance, we could add support for evaluating mathematical expressions as
follows by taking in the expression via an `onConfirm` callback, evaluating it with some third-party library,
then passing the result back into the numeric input:

<div class="pt-callout pt-intent-primary pt-icon-info-sign">
  By default, non-numeric values will be reset to `null` when the input loses focus or when the user
  presses `Enter`. However, if you provide an `onConfirm` callback, the input will pass the current value
  through to that callback unaffected, side-stepping the default validation behavior. (Otherwise,
  mathematical expressions, which may include non-numeric characters, would be reset to `null` before those
  expressions could be evaluated.)
</div>

```
import { NumericInput } from BlueprintComponents;

interface IState {
    value?: number | string;
}

export class NumericInputExample extends React.Component<{}, IState> {

    public constructor() {
        super();
        this.state = { value: null };
    }

    public render() {
        return (
            <NumericInput
                onConfirm={this.handleConfirm}
                value={this.state.value}
            />
        );
    }

    private handleConfirm = (value: string) {
        if (SomeLibrary.isNumber(value)) {
            return;
        }
        const result = SomeLibrary.evaluateMathExpression(value);
        this.setState({ value: result });
    }
}
```

@interface INumericInputProps

Weight: -10

Styleguide components.forms.numeric-input.js
*/

$pt-numeric-input-z-index-below: 1;
$pt-numeric-input-z-index-above: 2;

.pt-numeric-input {

  // we need a super-specific selector here to override very-specific selectors
  // defined elsewhere. -.-
  .pt-button-group.pt-vertical > .pt-button {
    @include pt-button-height($pt-button-height);

    // change to display: block to avoid a weird, jagged focus outline due to
    // the reduced line-height.
    display: block;
    min-height: $pt-button-height / 2;
    line-height: $pt-button-height / 2 - 1px;

    &:first-child {
      border-radius: 0 $pt-border-radius 0 0;
      height: ($pt-button-height / 2) + 1;
    }

    &:last-child {
      border-radius: 0 0 $pt-border-radius 0;
      height: $pt-button-height / 2;
    }

    &[class*="pt-icon-"]::before {
      // these styles are super unintuitive, but they basically are present to
      // ensure that the focus outlines around the buttons will be perfect
      // rectangles. delete any one of these styles, and the focus outlines will
      // become jagged, because we're trying to fit a 16-px tall icon inside a
      // ~15px-tall button.
      display: block;
      height: $pt-button-height / 2 - 1;
      overflow: hidden;
      line-height: $pt-button-height / 2 - 1;
    }
  }

  // fix button border radii when the buttons are on the left
  .pt-button-group:first-child.pt-vertical > .pt-button {
    &:first-child {
      border-radius: $pt-border-radius 0 0 0;
    }

    &:last-child {
      border-radius: 0 0 0 $pt-border-radius;
    }
  }

  // lift the focused group to the top so that its focus outline renders above
  // everything else (you'd think this would happen for free by using the
  // pt-control-group, but the fact that we're nesting groups within groups
  // breaks that assumption).

  &.pt-numeric-input-button-group-focused {
    .pt-button-group {
      z-index: $pt-numeric-input-z-index-above;

      // now within the button group's stacking context, lift the focused button
      // so that its focus outline appears on top when hovering over sibling
      // buttons.
      .pt-button:focus {
        z-index: $pt-numeric-input-z-index-above;
      }

      .pt-button:not(:focus) {
        z-index: $pt-numeric-input-z-index-below;
      }
    }

    .pt-input-group {
      z-index: $pt-numeric-input-z-index-below;
    }
  }

  &.pt-numeric-input-input-group-focused {
    .pt-input-group {
      z-index: $pt-numeric-input-z-index-above;
    }

    .pt-button-group {
      z-index: $pt-numeric-input-z-index-below;
    }
  }
}
