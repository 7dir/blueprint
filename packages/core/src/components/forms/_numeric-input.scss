
@import "../../common/variables";
@import "./common";

/*
Numeric inputs

Numeric inputs provide controls for inputting, incrementing, and decrementing a
numeric value.

Weight: 10

Styleguide components.forms.numeric-input
*/

/*
Interactions

Values in numeric inputs can be incremented or decremented using both keyboard and mouse interactions.

##### Keyboard interactions

- `↑/↓` - change the value by one step (default: `±1`)
- `Shift + ↑/↓` - change the value by one major step (default: `±10`)
- `Alt + ↑/↓` - change the value by one minor step (default: `±0.1`)
- `Enter` - triggers the `onConfirm` callback if provided; otherwise, clears invalid input

##### Mouse interactions

- `Click ⌃/⌄` - change the value by one step (default: `±1`)
- `Shift + Click ⌃/⌄` - change the value by one major step (default: `±10`)
- `Alt + Click ⌃/⌄` - change the value by one minor step (default: `±0.1`)

<div></div>

Weight: -1

Styleguide components.forms.numeric-input.interactions
*/

/*
Example

The following example is a configurable `NumericInput` that responds to the
keyboard and mouse interactions listed above.

@react-example NumericInputExample

Styleguide components.forms.numeric-input.example
*/

/*
JavaScript API

The `NumericInput` component is available in the __@blueprintjs/core__ package.
Make sure to review the [general usage docs for JS
components](#components.usage).

@interface INumericInputProps

Styleguide components.forms.numeric-input.js
*/

/*
Uncontrolled mode

By default, this component will function in uncontrolled mode, managing all of
its own state. In uncontrolled mode, simply provide an `onChange` callback in
the props to access the value as the user manipulates it. The value will be
received as a `number` type if it is parseable as a number; otherwise, it will
be received as a `string`. The interactive example earlier in this section
illustrates this variable-type behavior concretely.

```
import { NumericInput } from BlueprintComponents;

export class NumericInputExample extends React.Component<{}, {}> {
    public render() {
        return (
            <NumericInput onChange={this.handleChange} />
        );
    }

    private handleChange = (value: number | string) => console.log(value);
}
```

Weight: -1

Styleguide components.forms.numeric-input.js.uncontrolled
*/

/*
Controlled mode

You can pass in the `value` as a prop to operate in **controlled mode**.
Together with the `onChange` and `onConfirm` callbacks, controlling the `value`
makes it possible to extend the component's basic functionality in powerful
ways. For instance, in addition to the basic numeric-entry functionality, you
could extend the field to support mathematical expressions by receiving the
user's typed expression as a `string` via an `onConfirm` callback, evaluating it
with some third-party math library, then passing the result back into the
component via the `value` prop.

See below for some sample code that extends the numeric input component with
support for mathematical expressions.

<div class="pt-callout pt-intent-primary pt-icon-info-sign">
  By default, non-numeric values will be considered invalid and cleared when the
  input loses focus or when the user presses `Enter`. However, if you provide an
  `onConfirm` callback, the input will pass the current value through to that
  callback unaffected, side-stepping the default validation behavior. (Otherwise,
  mathematical expressions, which may include non-numeric characters, would be
  cleared before those expressions could be evaluated.)
</div>

```
import { NumericInput } from BlueprintComponents;

export class NumericInputExample extends React.Component<{}, { value?: number |
string }> {
    public state = { value: null };

    public render() {
        return (
            <NumericInput
                onConfirm={this.handleConfirm}
                value={this.state.value}
            />
        );
    }

    private handleConfirm = (value: string) {
        if (SomeLibrary.isNumber(value)) {
            return;
        }
        const result = SomeLibrary.evaluateMathExpression(value);
        this.setState({ value: result });
    }
}
```

Styleguide components.forms.numeric-input.js.controlled
*/

$pt-numeric-input-z-index-below: 1;
$pt-numeric-input-z-index-above: 2;

.pt-numeric-input {

  // we need a super-specific selector here to override very-specific selectors
  // defined elsewhere. -.-
  .pt-button-group.pt-vertical > .pt-button {
    @include pt-button-height($pt-button-height);

    // change to display: block to avoid a weird, jagged focus outline due to
    // the reduced line-height.
    display: block;
    min-height: $pt-button-height / 2;
    line-height: $pt-button-height / 2 - 1px;

    &:first-child {
      border-radius: 0 $pt-border-radius 0 0;
      height: ($pt-button-height / 2) + 1;
    }

    &:last-child {
      border-radius: 0 0 $pt-border-radius 0;
      height: $pt-button-height / 2;
    }

    &[class*="pt-icon-"]::before {
      // these styles are super unintuitive, but they basically are present to
      // ensure that the focus outlines around the buttons will be perfect
      // rectangles. delete any one of these styles, and the focus outlines will
      // become jagged, because we're trying to fit a 16-px tall icon inside a
      // ~15px-tall button.
      display: block;
      height: $pt-button-height / 2 - 1;
      overflow: hidden;
      line-height: $pt-button-height / 2 - 1;
    }
  }

  // fix button border radii when the buttons are on the left
  .pt-button-group:first-child.pt-vertical > .pt-button {
    &:first-child {
      border-radius: $pt-border-radius 0 0 0;
    }

    &:last-child {
      border-radius: 0 0 0 $pt-border-radius;
    }
  }

  // lift the focused group to the top so that its focus outline renders above
  // everything else (you'd think this would happen for free by using the
  // pt-control-group, but the fact that we're nesting groups within groups
  // breaks that assumption).

  &.pt-numeric-input-button-group-focused {
    .pt-button-group {
      z-index: $pt-numeric-input-z-index-above;

      // now within the button group's stacking context, lift the focused button
      // so that its focus outline appears on top when hovering over sibling
      // buttons.
      .pt-button:focus {
        z-index: $pt-numeric-input-z-index-above;
      }

      .pt-button:not(:focus) {
        z-index: $pt-numeric-input-z-index-below;
      }
    }

    .pt-input-group {
      z-index: $pt-numeric-input-z-index-below;
    }
  }

  &.pt-numeric-input-input-group-focused {
    .pt-input-group {
      z-index: $pt-numeric-input-z-index-above;
    }

    .pt-button-group {
      z-index: $pt-numeric-input-z-index-below;
    }
  }
}
